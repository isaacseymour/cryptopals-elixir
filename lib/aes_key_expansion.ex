defmodule AESKeyExpansion do
  use Bitwise

  @rcon [
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
  ]
  @nk 4 # Key length for AES-128. 6 for AES-192, 8 for AES-256
  @nr 10 # Number of rounds for AES-128. 12 for AES-192, 14 for AES-256

  def sub_word(word), do: AES.sub_bytes(word)

  def rot_word({bytes, 0}), do: bytes
  def rot_word({[head | tail], places}) do
    rot_word({tail ++ [head], places - 1})
  end
  def rot_word(word), do: rot_word({word, 1})

  def expand(keybytes) do
    first_words = keybytes |> Enum.chunk(4)
    1..10 |> Enum.reduce(first_words, fn round, words ->
      subbed = sub_word(rot_word(Enum.at(words, -1)))
      rcon = [Enum.at(@rcon, round), 0, 0, 0]
      first_new_word = xor(xor(subbed, rcon), Enum.at(words, -4))

      second_new_word = xor(first_new_word, Enum.at(words, -3))
      third_new_word = xor(second_new_word, Enum.at(words, -2))
      fourth_new_word = xor(third_new_word, Enum.at(words, -1))

      words ++ [
        first_new_word,
        second_new_word,
        third_new_word,
        fourth_new_word
      ]
    end)
  end

  def expand_iter(words, @nk * 11), do: words
  def expand_iter(words, i) do
    prev = Enum.at(words, -1)
    partner = Enum.at(words, -4)

    if Integer.mod(i, @nk) == 0 do
      processed = xor(
                      sub_word(rot_word(prev)),
                      Enum.at(@rcon, Integer.floor_div(i, @nk))
                    )
      new_word = xor(processed, partner)
      expand_iter(words + [new_word], i + 1)
    else
      new_word = xor(prev, partner)
      expand_iter(words + [new_word], i + 1)
    end
  end

  def xor(bytes1, bytes2), do: Enum.zip(bytes1, bytes2) |> Enum.map(fn {a, b} -> bxor(a, b) end)
end
